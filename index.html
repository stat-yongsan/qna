<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://tymlgppoppslipyyynxk.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR5bWxncHBvcHBzbGlweXl5bnhrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI3MzM0MzUsImV4cCI6MjA3ODMwOTQzNX0.0PbyrnbNgMxmE8sWpRq4wWkWLL66L8EZvF0CDRdG2j8";
  const SUPABASE_READY =
    !SUPABASE_URL.includes("YOUR_SUPABASE") &&
    !SUPABASE_ANON_KEY.includes("YOUR_SUPABASE");

  const supabaseClient = window.supabase.createClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY
  );

  const QUESTIONS_TABLE = "questions";
  const MAX_ATTACHMENTS = 5;
  const MAX_IMAGE_BYTES = 5 * 1024 * 1024;
  const ITEMS_PER_PAGE = 10;

  const form = document.getElementById("question-form");
  const list = document.getElementById("question-list");
  const emptyState = document.getElementById("empty-state");
  const template = document.getElementById("question-card-template");
  const pagination = document.getElementById("pagination");
  const questionTextarea = document.getElementById("question");
  const attachmentPreview = document.getElementById(
    "question-attachment-preview"
  );

  const deviceId = getDeviceId();
  let items = [];
  let questionAttachments = [];
  let currentPage = 1;
  let realtimeChannel = null;

  function getDeviceId() {
    let id = localStorage.getItem("center-qna-device-id");
    if (!id) {
      id = crypto.randomUUID();
      localStorage.setItem("center-qna-device-id", id);
    }
    return id;
  }

  function formatDate(timestamp) {
    const date = new Date(timestamp);
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, "0");
    const dd = String(date.getDate()).padStart(2, "0");
    const hh = String(date.getHours()).padStart(2, "0");
    const min = String(date.getMinutes()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd} ${hh}:${min}`;
  }

  function cloneAttachments(list = []) {
    return list.map((item) => ({
      id: item.id || crypto.randomUUID(),
      dataUrl: item.dataUrl,
      mimeType: item.mimeType,
      name: item.name || null,
      addedAt: item.addedAt || Date.now(),
    }));
  }

  function renderAttachmentGallery(container, attachments) {
    if (!attachments || !attachments.length) {
      container.innerHTML = "";
      container.hidden = true;
      return;
    }
    container.hidden = false;
    container.innerHTML = "";
    attachments.forEach((attachment) => {
      const link = document.createElement("a");
      link.href = attachment.dataUrl;
      link.target = "_blank";
      link.rel = "noopener";
      if (attachment.name) {
        link.download = attachment.name;
        link.title = attachment.name;
      }
      const img = document.createElement("img");
      img.src = attachment.dataUrl;
      img.alt = attachment.name || "첨부 이미지";
      img.className = "attachment-thumb";
      link.appendChild(img);
      container.appendChild(link);
    });
  }

  function renderAttachmentPreview(previewEl, attachments) {
    if (!attachments.length) {
      previewEl.innerHTML =
        '<p class="attachment-empty">붙여넣기(Ctrl+V)로 이미지를 첨부할 수 있습니다.</p>';
      return;
    }
    previewEl.innerHTML = "";
    attachments.forEach((attachment) => {
      const wrapper = document.createElement("div");
      wrapper.className = "attachment-item";

      const img = document.createElement("img");
      img.src = attachment.dataUrl;
      img.alt = attachment.name || "첨부 이미지";
      img.className = "attachment-thumb";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "attachment-remove";
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", () => {
        questionAttachments = questionAttachments.filter(
          (entry) => entry.id !== attachment.id
        );
        renderAttachmentPreview(previewEl, questionAttachments);
      });

      wrapper.appendChild(img);
      wrapper.appendChild(removeBtn);
      previewEl.appendChild(wrapper);
    });
  }

  async function addAttachmentsFromFiles(files, attachments, renderFn) {
    for (const file of files) {
      if (!file) continue;
      if (!file.type.startsWith("image/")) continue;
      if (attachments.length >= MAX_ATTACHMENTS) {
        alert(`이미지는 최대 ${MAX_ATTACHMENTS}개까지 첨부할 수 있습니다.`);
        break;
      }
      if (file.size > MAX_IMAGE_BYTES) {
        alert("이미지 크기는 5MB 이하여야 합니다.");
        continue;
      }
      try {
        const dataUrl = await readFileDataURL(file);
        attachments.push({
          id: crypto.randomUUID(),
          dataUrl,
          mimeType: file.type,
          name: file.name || "clipboard-image",
          addedAt: Date.now(),
        });
      } catch (error) {
        console.error(error);
        alert("이미지 첨부에 실패했습니다. 다시 시도해주세요.");
      }
    }
    renderFn();
  }

  function readFileDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(new Error("Failed to read file"));
      reader.readAsDataURL(file);
    });
  }

  function renderPagination(totalItems) {
    const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);

    if (totalPages <= 1) {
      pagination.hidden = true;
      pagination.innerHTML = "";
      return;
    }

    pagination.hidden = false;
    pagination.innerHTML = "";

    const prevBtn = document.createElement("button");
    prevBtn.type = "button";
    prevBtn.textContent = "이전";
    prevBtn.disabled = currentPage === 1;
    prevBtn.addEventListener("click", () => {
      if (currentPage > 1) {
        currentPage -= 1;
        renderItems();
      }
    });

    const nextBtn = document.createElement("button");
    nextBtn.type = "button";
    nextBtn.textContent = "다음";
    nextBtn.disabled = currentPage >= totalPages;
    nextBtn.addEventListener("click", () => {
      if (currentPage < totalPages) {
        currentPage += 1;
        renderItems();
      }
    });

    const status = document.createElement("span");
    status.className = "page-status";
    status.textContent = `${currentPage} / ${totalPages}`;

    pagination.appendChild(prevBtn);
    pagination.appendChild(status);
    pagination.appendChild(nextBtn);
  }

  function normalizeRow(row) {
    return {
      id: row.id,
      department: row.department,
      question: row.question,
      attachments: row.attachments || [],
      answer: row.answer || "",
      answerAttachments: row.answer_attachments || [],
      status: row.status || "pending",
      sessionId: row.session_id || null,
      createdAt: row.created_at ? new Date(row.created_at).getTime() : Date.now(),
      updatedAt: row.updated_at ? new Date(row.updated_at).getTime() : Date.now(),
    };
  }

  async function refreshItems() {
    if (!SUPABASE_READY) {
      items = [];
      renderItems();
      return;
    }
    try {
      const { data, error } = await supabaseClient
        .from(QUESTIONS_TABLE)
        .select("*")
        .eq("session_id", deviceId)
        .order("updated_at", { ascending: false });
      if (error) throw error;
      items = (data || []).map(normalizeRow);
    } catch (error) {
      console.error("질문 목록을 불러오지 못했습니다.", error);
      items = [];
    }
    renderItems();
  }

  function renderItems() {
    list.innerHTML = "";

    if (!SUPABASE_READY) {
      emptyState.hidden = false;
      emptyState.textContent =
        "Supabase 설정을 완료하면 질문을 불러올 수 있습니다.";
      pagination.hidden = true;
      pagination.innerHTML = "";
      return;
    }

    if (!items.length) {
      emptyState.hidden = false;
      renderPagination(0);
      return;
    }

    emptyState.hidden = true;
    const totalPages = Math.ceil(items.length / ITEMS_PER_PAGE);
    if (currentPage > totalPages) {
      currentPage = totalPages;
    }

    const start = (currentPage - 1) * ITEMS_PER_PAGE;
    const pageItems = items.slice(start, start + ITEMS_PER_PAGE);

    pageItems.forEach((item) => {
      const card = template.content.firstElementChild.cloneNode(true);
      const chip = card.querySelector(".chip");
      const meta = card.querySelector(".meta");
      const questionText = card.querySelector(".question-text");
      const questionAttachmentsContainer = card.querySelector(".question-attachments");
      const answerBlock = card.querySelector(".answer-block");
      const answerAttachmentsContainer = card.querySelector(".answer-attachments-display");
      const updatedAt = card.querySelector(".updated-at");

      chip.textContent = item.status === "answered" ? "답변 완료" : "답변 대기";
      chip.classList.add(item.status === "answered" ? "answered" : "pending");

      meta.textContent = item.department;
      questionText.textContent = item.question;

      renderAttachmentGallery(questionAttachmentsContainer, item.attachments);

      if (item.answer) {
        answerBlock.textContent = item.answer;
        answerBlock.classList.remove("empty");
      } else {
        answerBlock.textContent = "답변이 아직 등록되지 않았습니다.";
        answerBlock.classList.add("empty");
      }

      renderAttachmentGallery(answerAttachmentsContainer, item.answerAttachments);
      updatedAt.textContent = `최근 업데이트: ${formatDate(item.updatedAt)}`;

      list.appendChild(card);
    });

    renderPagination(items.length);
  }

  async function handleQuestionSubmit(event) {
    event.preventDefault();

    if (!SUPABASE_READY) {
      alert("Supabase 설정을 완료한 뒤 질문을 등록할 수 있습니다.");
      return;
    }

    const department = document.getElementById("department").value.trim();
    const question = questionTextarea.value.trim();

    if (!department || !question) {
      return;
    }

    const payload = {
      department,
      question,
      attachments: cloneAttachments(questionAttachments),
      answer: "",
      answer_attachments: [],
      status: "pending",
      session_id: deviceId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    try {
      const { error } = await supabaseClient.from(QUESTIONS_TABLE).insert([payload]);
      if (error) throw error;
      currentPage = 1;
      questionAttachments = [];
      renderAttachmentPreview(attachmentPreview, questionAttachments);
      form.reset();
      document.getElementById("department").focus();
      await refreshItems();
    } catch (error) {
      console.error("질문 등록에 실패했습니다.", error);
      alert("질문 등록에 실패했습니다. 잠시 후 다시 시도해주세요.");
    }
  }

  form.addEventListener("submit", handleQuestionSubmit);

  questionTextarea.addEventListener("paste", async (event) => {
    const items = event.clipboardData?.items;
    if (!items) return;
    const files = Array.from(items)
      .filter((item) => item.kind === "file" && item.type.startsWith("image/"))
      .map((item) => item.getAsFile())
      .filter(Boolean);
    if (!files.length) return;

    await addAttachmentsFromFiles(files, questionAttachments, () => {
      renderAttachmentPreview(attachmentPreview, questionAttachments);
    });
  });

  renderAttachmentPreview(attachmentPreview, questionAttachments);

  if (SUPABASE_READY) {
    realtimeChannel = supabaseClient
      .channel(`public:${QUESTIONS_TABLE}:session:${deviceId}`)
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: QUESTIONS_TABLE, filter: `session_id=eq.${deviceId}` },
        () => refreshItems()
      )
      .subscribe();

    window.addEventListener("beforeunload", () => {
      if (realtimeChannel) {
        supabaseClient.removeChannel(realtimeChannel);
      }
    });
  }

  refreshItems();
</script>
</body>
</html>