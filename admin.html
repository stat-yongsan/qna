<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://YOUR_SUPABASE_PROJECT_URL.supabase.co";
  const SUPABASE_ANON_KEY = "YOUR_SUPABASE_ANON_KEY";
  const SUPABASE_READY =
    !SUPABASE_URL.includes("YOUR_SUPABASE") &&
    !SUPABASE_ANON_KEY.includes("YOUR_SUPABASE");

  const supabaseClient = window.supabase.createClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY
  );

  const QUESTIONS_TABLE = "questions";
  const MAX_ATTACHMENTS = 5;
  const MAX_IMAGE_BYTES = 5 * 1024 * 1024;
  const ADMIN_ITEMS_PER_PAGE = 10;
  const ADMIN_SESSION_KEY = "center-qna-admin-session-v1";
  const ADMIN_ACCOUNT = { id: "admin", password: "8460" };

  const loginForm = document.getElementById("login-form");
  const loginSection = document.getElementById("login-section");
  const dashboardSection = document.getElementById("dashboard-section");
  const list = document.getElementById("question-list");
  const emptyState = document.getElementById("empty-state");
  const template = document.getElementById("question-card-template");
  const welcomeText = document.getElementById("welcome-text");
  const roleChip = document.getElementById("role-chip");
  const logoutBtn = document.getElementById("logout-btn");
  const adminIdInput = document.getElementById("admin-id");
  const adminPasswordInput = document.getElementById("admin-password");
  const adminPagination = document.getElementById("admin-pagination");

  let items = [];
  const answerAttachmentDrafts = new Map();
  let currentUser = loadSession();
  let adminCurrentPage = 1;
  let realtimeChannel = null;

  function loadSession() {
    try {
      const stored = sessionStorage.getItem(ADMIN_SESSION_KEY);
      if (!stored) return null;
      const parsed = JSON.parse(stored);
      if (!parsed || typeof parsed !== "object") return null;
      return parsed;
    } catch (error) {
      console.error("관리자 세션 로드 실패", error);
      return null;
    }
  }

  function persistSession(user) {
    if (user) {
      sessionStorage.setItem(ADMIN_SESSION_KEY, JSON.stringify(user));
    } else {
      sessionStorage.removeItem(ADMIN_SESSION_KEY);
    }
  }

  function formatDate(timestamp) {
    const date = new Date(timestamp);
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, "0");
    const dd = String(date.getDate()).padStart(2, "0");
    const hh = String(date.getHours()).padStart(2, "0");
    const min = String(date.getMinutes()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd} ${hh}:${min}`;
  }

  function cloneAttachments(list = []) {
    return list.map((item) => ({
      id: item.id || crypto.randomUUID(),
      dataUrl: item.dataUrl,
      mimeType: item.mimeType,
      name: item.name || null,
      addedAt: item.addedAt || Date.now(),
    }));
  }

  function renderAttachmentGallery(container, attachments) {
    if (!attachments || !attachments.length) {
      container.innerHTML = "";
      container.hidden = true;
      return;
    }
    container.hidden = false;
    container.innerHTML = "";
    attachments.forEach((attachment) => {
      const link = document.createElement("a");
      link.href = attachment.dataUrl;
      link.target = "_blank";
      link.rel = "noopener";
      if (attachment.name) {
        link.download = attachment.name;
        link.title = attachment.name;
      }
      const img = document.createElement("img");
      img.src = attachment.dataUrl;
      img.alt = attachment.name || "첨부 이미지";
      img.className = "attachment-thumb";
      link.appendChild(img);
      container.appendChild(link);
    });
  }

  function renderAnswerAttachmentDraft(itemId, previewEl) {
    const attachments = answerAttachmentDrafts.get(itemId) || [];
    if (!attachments.length) {
      previewEl.innerHTML =
        '<p class="attachment-empty">붙여넣기(Ctrl+V)로 이미지를 첨부할 수 있습니다.</p>';
      return;
    }
    previewEl.innerHTML = "";
    attachments.forEach((attachment) => {
      const wrapper = document.createElement("div");
      wrapper.className = "attachment-item";

      const img = document.createElement("img");
      img.src = attachment.dataUrl;
      img.alt = attachment.name || "첨부 이미지";
      img.className = "attachment-thumb";

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "attachment-remove";
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", () => {
        const next = (answerAttachmentDrafts.get(itemId) || []).filter(
          (entry) => entry.id !== attachment.id
        );
        answerAttachmentDrafts.set(itemId, next);
        renderAnswerAttachmentDraft(itemId, previewEl);
      });

      wrapper.appendChild(img);
      wrapper.appendChild(removeBtn);
      previewEl.appendChild(wrapper);
    });
  }

  async function addAttachmentsFromFiles(files, attachments, renderFn) {
    for (const file of files) {
      if (!file) continue;
      if (!file.type.startsWith("image/")) continue;
      if (attachments.length >= MAX_ATTACHMENTS) {
        alert(`이미지는 최대 ${MAX_ATTACHMENTS}개까지 첨부할 수 있습니다.`);
        break;
      }
      if (file.size > MAX_IMAGE_BYTES) {
        alert("이미지 크기는 5MB 이하여야 합니다.");
        continue;
      }
      try {
        const dataUrl = await readFileDataURL(file);
        attachments.push({
          id: crypto.randomUUID(),
          dataUrl,
          mimeType: file.type,
          name: file.name || "clipboard-image",
          addedAt: Date.now(),
        });
      } catch (error) {
        console.error(error);
        alert("이미지 첨부에 실패했습니다. 다시 시도해주세요.");
      }
    }
    renderFn();
  }

  function readFileDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(new Error("Failed to read file"));
      reader.readAsDataURL(file);
    });
  }

  function renderAdminPagination(totalItems) {
    const totalPages = Math.ceil(totalItems / ADMIN_ITEMS_PER_PAGE);

    if (totalPages <= 1) {
      adminPagination.hidden = true;
      adminPagination.innerHTML = "";
      return;
    }

    adminPagination.hidden = false;
    adminPagination.innerHTML = "";

    const prevBtn = document.createElement("button");
    prevBtn.type = "button";
    prevBtn.textContent = "이전";
    prevBtn.disabled = adminCurrentPage === 1;
    prevBtn.addEventListener("click", () => {
      if (adminCurrentPage > 1) {
        adminCurrentPage -= 1;
        renderItems();
      }
    });

    const nextBtn = document.createElement("button");
    nextBtn.type = "button";
    nextBtn.textContent = "다음";
    nextBtn.disabled = adminCurrentPage >= totalPages;
    nextBtn.addEventListener("click", () => {
      if (adminCurrentPage < totalPages) {
        adminCurrentPage += 1;
        renderItems();
      }
    });

    const status = document.createElement("span");
    status.className = "page-status";
    status.textContent = `${adminCurrentPage} / ${totalPages}`;

    adminPagination.appendChild(prevBtn);
    adminPagination.appendChild(status);
    adminPagination.appendChild(nextBtn);
  }

  function normalizeRow(row) {
    return {
      id: row.id,
      department: row.department,
      question: row.question,
      attachments: row.attachments || [],
      answer: row.answer || "",
      answerAttachments: row.answer_attachments || [],
      status: row.status || "pending",
      sessionId: row.session_id || null,
      contactName: row.contact_name || null,
      contactInfo: row.contact_info || null,
      createdAt: row.created_at ? new Date(row.created_at).getTime() : Date.now(),
      updatedAt: row.updated_at ? new Date(row.updated_at).getTime() : Date.now(),
    };
  }

  async function refreshItems() {
    if (!currentUser || !SUPABASE_READY) {
      items = [];
      renderItems();
      return;
    }

    try {
      const { data, error } = await supabaseClient
        .from(QUESTIONS_TABLE)
        .select("*")
        .order("updated_at", { ascending: false });
      if (error) throw error;
      const normalized = (data || []).map(normalizeRow);
      const knownIds = new Set();
      normalized.forEach((item) => {
        knownIds.add(item.id);
        if (!answerAttachmentDrafts.has(item.id)) {
          answerAttachmentDrafts.set(item.id, cloneAttachments(item.answerAttachments));
        }
      });
      Array.from(answerAttachmentDrafts.keys()).forEach((id) => {
        if (!knownIds.has(id)) {
          answerAttachmentDrafts.delete(id);
        }
      });
      items = normalized.sort((a, b) => b.updatedAt - a.updatedAt);
    } catch (error) {
      console.error("질문 목록을 불러오지 못했습니다.", error);
      items = [];
    }

    renderItems();
  }

  function renderItems() {
    list.innerHTML = "";

    if (!currentUser) {
      emptyState.hidden = true;
      adminPagination.hidden = true;
      adminPagination.innerHTML = "";
      return;
    }

    if (!SUPABASE_READY) {
      emptyState.hidden = false;
      emptyState.textContent = "Supabase 설정을 완료하면 질문을 불러올 수 있습니다.";
      adminPagination.hidden = true;
      adminPagination.innerHTML = "";
      return;
    }

    if (!items.length) {
      emptyState.hidden = false;
      emptyState.textContent =
        "등록된 질문이 없습니다. 학과에서 질문을 등록하면 이곳에 표시됩니다.";
      renderAdminPagination(0);
      return;
    }

    emptyState.hidden = true;

    const totalPages = Math.ceil(items.length / ADMIN_ITEMS_PER_PAGE);
    if (adminCurrentPage > totalPages) {
      adminCurrentPage = totalPages;
    }

    const start = (adminCurrentPage - 1) * ADMIN_ITEMS_PER_PAGE;
    const pageItems = items.slice(start, start + ADMIN_ITEMS_PER_PAGE);

    pageItems.forEach((item) => {
      if (!answerAttachmentDrafts.has(item.id)) {
        answerAttachmentDrafts.set(item.id, cloneAttachments(item.answerAttachments));
      }

      const card = template.content.firstElementChild.cloneNode(true);
      const chip = card.querySelector(".chip");
      const meta = card.querySelector(".meta");
      const questionText = card.querySelector(".question-text");
      const questionAttachmentsContainer = card.querySelector(".question-attachments");
      const answerBlock = card.querySelector(".answer-block");
      const answerAttachmentsContainer = card.querySelector(".answer-attachments-display");
      const updatedAt = card.querySelector(".updated-at");
      const toggleBtn = card.querySelector(".toggle-answer-btn");
      const answerForm = card.querySelector(".answer-form");
      const answerTextarea = answerForm.querySelector("textarea");
      const cancelAnswerBtn = answerForm.querySelector(".cancel-answer-btn");
      const answerPreview = answerForm.querySelector(".answer-attachment-preview");
      const editQuestionBtn = card.querySelector(".edit-question-btn");
      const deleteQuestionBtn = card.querySelector(".delete-question-btn");
      const questionEditForm = card.querySelector(".question-edit-form");
      const questionEditTextarea = questionEditForm.querySelector("textarea");
      const questionEditCancelBtn = questionEditForm.querySelector(".cancel-question-btn");

      chip.textContent = item.status === "answered" ? "답변 완료" : "답변 대기";
      chip.classList.add(item.status === "answered" ? "answered" : "pending");

      meta.textContent = item.department;
      questionText.textContent = item.question;

      renderAttachmentGallery(questionAttachmentsContainer, item.attachments);
      renderAttachmentGallery(answerAttachmentsContainer, item.answerAttachments);

      if (item.answer) {
        answerBlock.textContent = item.answer;
        answerBlock.classList.remove("empty");
      } else {
        answerBlock.textContent = "답변이 아직 등록되지 않았습니다.";
        answerBlock.classList.add("empty");
      }

      updatedAt.textContent = `최근 업데이트: ${formatDate(item.updatedAt)}`;

      editQuestionBtn.addEventListener("click", () => {
        const isOpen = !questionEditForm.hidden;
        document.querySelectorAll(".question-edit-form").forEach((formEl) => {
          if (formEl !== questionEditForm) formEl.hidden = true;
        });
        document.querySelectorAll(".answer-form").forEach((formEl) => {
          formEl.hidden = true;
        });

        if (isOpen) {
          questionEditForm.hidden = true;
        } else {
          questionEditTextarea.value = item.question;
          questionEditForm.hidden = false;
          questionEditTextarea.focus();
        }
      });

      questionEditForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const value = questionEditTextarea.value.trim();
        if (!value) {
          alert("질문 내용을 입력해주세요.");
          questionEditTextarea.focus();
          return;
        }
        if (!SUPABASE_READY) {
          alert("Supabase 설정을 완료한 뒤 사용할 수 있습니다.");
          return;
        }
        try {
          const { error } = await supabaseClient
            .from(QUESTIONS_TABLE)
            .update({
              question: value,
              updated_at: new Date().toISOString(),
            })
            .eq("id", item.id);
          if (error) throw error;
          questionEditForm.hidden = true;
          await refreshItems();
        } catch (error) {
          console.error("질문 수정에 실패했습니다.", error);
          alert("질문 수정에 실패했습니다. 잠시 후 다시 시도해주세요.");
        }
      });

      questionEditCancelBtn.addEventListener("click", () => {
        questionEditForm.hidden = true;
      });

      deleteQuestionBtn.addEventListener("click", async () => {
        if (!SUPABASE_READY) {
          alert("Supabase 설정을 완료한 뒤 사용할 수 있습니다.");
          return;
        }
        const confirmed = confirm(
          "이 질문을 삭제하시겠습니까? 삭제 후에는 되돌릴 수 없습니다."
        );
        if (!confirmed) return;
        try {
          const { error } = await supabaseClient
            .from(QUESTIONS_TABLE)
            .delete()
            .eq("id", item.id);
          if (error) throw error;
          const remaining = items.length - 1;
          const totalPagesAfter = Math.ceil(remaining / ADMIN_ITEMS_PER_PAGE) || 1;
          if (adminCurrentPage > totalPagesAfter) {
            adminCurrentPage = totalPagesAfter;
          }
          await refreshItems();
        } catch (error) {
          console.error("질문 삭제에 실패했습니다.", error);
          alert("질문 삭제에 실패했습니다. 잠시 후 다시 시도해주세요.");
        }
      });

      toggleBtn.textContent = item.answer ? "답변 수정" : "답변 등록";
      toggleBtn.addEventListener("click", () => {
        const isOpen = !answerForm.hidden;
        document.querySelectorAll(".answer-form").forEach((formEl) => {
          if (formEl !== answerForm) formEl.hidden = true;
        });
        document.querySelectorAll(".question-edit-form").forEach((formEl) => {
          formEl.hidden = true;
        });

